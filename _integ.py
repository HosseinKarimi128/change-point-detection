import argparse
from pathlib import Path
import chardet # type: ignore
 

def detect_encoding(file_path, num_bytes=10000):
    """
    Detects the encoding of a file using chardet.

    Parameters:
    - file_path (Path): Path to the file.
    - num_bytes (int): Number of bytes to read for detection.

    Returns:
    - str: Detected encoding or 'utf-8' as default.
    """
    with file_path.open('rb') as f:
        rawdata = f.read(num_bytes)
    result = chardet.detect(rawdata)
    encoding = result['encoding']
    if not encoding:
        encoding = 'utf-8'
    return encoding

def combine_python_files(source_dir, output_file):
    """
    Combines all Python (.py) files in the specified directory and its immediate first-level subdirectories
    into a single Python file, excluding the output file itself.

    Parameters:
    - source_dir (str or Path): The directory containing Python files to combine.
    - output_file (str or Path): The path to the output Python file.

    Raises:
    - FileNotFoundError: If the source directory does not exist.
    - IOError: If there are issues reading or writing files.
    """
    source_path = Path(source_dir).resolve()
    output_path = Path(output_file).resolve()

    if not source_path.is_dir():
        raise FileNotFoundError(f"The directory {source_dir} does not exist.")

    # Initialize a set to store Python files
    python_files = set()

    # Add .py files from the top-level source directory
    top_level_files = sorted(source_path.glob("*.py"))
    python_files.update(top_level_files)

    # Add .py files from immediate first-level subdirectories
    first_level_dirs = [d for d in source_path.iterdir() if d.is_dir()]
    for sub_dir in first_level_dirs:
        sub_dir_py_files = sorted(sub_dir.glob("*.py"))
        python_files.update(sub_dir_py_files)

    # Convert the set to a sorted list
    python_files = sorted(python_files)

    # Exclude the output file itself if it's within the source directory or its first-level subdirectories
    python_files = [py_file for py_file in python_files if py_file.resolve() != output_path]

    if not python_files:
        print(f"No Python files found in directory and its immediate subdirectories: {source_dir}")
        return

    try:
        with output_path.open('w', encoding='utf-8') as outfile:
            outfile.write("# Combined Python File\n")
            outfile.write("# This file is autogenerated by combine_python_files function\n\n")
            
            for py_file in python_files:
                # Detect file encoding
                encoding = detect_encoding(py_file)
                
                # Compute the relative path for better readability in comments
                relative_path = py_file.relative_to(source_path)
                outfile.write(f"# ----- Begin {relative_path} (Encoding: {encoding}) -----\n")
                
                with py_file.open('r', encoding=encoding, errors='replace') as infile:
                    contents = infile.read()
                    outfile.write(contents)
                    outfile.write("\n\n")
                
                outfile.write(f"# ----- End {relative_path} -----\n\n")
        
        print(f"Successfully combined {len(python_files)} files into {output_file}")
    
    except IOError as e:
        print(f"An error occurred while reading or writing files: {e}")

def main():
    """
    Main function to parse command-line arguments and invoke the combine function.
    """
    parser = argparse.ArgumentParser(
        description="Combine all Python (.py) files in a directory and its immediate first-level subdirectories into a single Python file."
    )
    parser.add_argument(
        "source_dir",
        type=str,
        help="Path to the source directory containing Python files."
    )
    parser.add_argument(
        "output_file",
        nargs='?',
        default="combined.py",
        help="Path to the output Python file. Defaults to 'combined.py' in the current directory."
    )
    
    args = parser.parse_args()

    combine_python_files(args.source_dir, args.output_file)

if __name__ == "__main__":
    main()
